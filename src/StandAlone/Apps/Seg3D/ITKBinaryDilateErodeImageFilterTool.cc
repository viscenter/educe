

#include <StandAlone/Apps/Seg3D/ITKBinaryDilateErodeImageFilterTool.h>
#include <itkBinaryBallStructuringElement.h>
#include <itkBinaryDilateImageFilter.h>
#include <itkBinaryErodeImageFilter.h>
#include <itkImportImageFilter.h>
#include <StandAlone/Apps/Seg3D/Seg3DFrame.h>
#include <StandAlone/Apps/Seg3D/BrushTool.h>
#include <StandAlone/Apps/Seg3D/Painter.h>
#include <StandAlone/Apps/Seg3D/VolumeOps.h>
#include <Core/Util/Assert.h>

namespace SCIRun {


ITKBinaryDilateErodeImageFilterTool::ITKBinaryDilateErodeImageFilterTool(Painter *painter)
  : BaseTool("ITKBinaryDilateErodeImageFilterTool::"),
    PointerTool("ITKBinaryDilateErodeImageFilterTool::"),
    painter_(painter)
{
}


BaseTool::propagation_state_e 
ITKBinaryDilateErodeImageFilterTool::process_event(event_handle_t event)
{
  // Check for the FinishEvent signal generated by the start button
  if (dynamic_cast<DilateEvent *>(event.get_rep())) {
    if (!painter_->check_for_active_label_volume("Binary dilate"))
    {
      return STOP_E;
    }
    painter_->set_status("Dilating " + painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    run_dilate_filter();
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }
  if (dynamic_cast<ErodeEvent *>(event.get_rep())) {
    if (!painter_->check_for_active_label_volume("Binary erode"))
    {
      return STOP_E;
    }
    painter_->set_status("Eroding " + painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    run_erode_filter();
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }
  if (dynamic_cast<DilateErodeEvent *>(event.get_rep())) {
    if (!painter_->check_for_active_label_volume("Binary dilate/erode"))
    {
      return STOP_E;
    }
    painter_->set_status("Dilating and then eroding " + painter_->current_volume_->name_ + ".");
    painter_->start_progress();
    run_dilate_erode_filter();
    painter_->finish_progress();
    painter_->extract_all_window_slices();
    painter_->redraw_all();
  }
 
  return CONTINUE_E;
}


void
ITKBinaryDilateErodeImageFilterTool::run_dilate_filter(bool force_no_copy)
{
  const bool copy_needed =
    !force_no_copy && painter_->current_volume_->compute_label_mask() != 1;

  NrrdVolumeHandle srcdst = painter_->current_volume_;

  if (copy_needed)
  {
    // Make a temporary volume with only the one bit plane in it for ITK.
    NrrdDataHandle nrrdh =
      VolumeOps::create_clear_nrrd(painter_->current_volume_->nrrd_handle_,
                                   LabelNrrdType);

    const string name = "Unused";
    srcdst = new NrrdVolume(painter_, name, nrrdh, 1);

    VolumeOps::bit_copy(srcdst->nrrd_handle_, 1,
                        painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_);
  }
                      
  const string name = "ITKBinaryDilateErodeImageFilterTool::";

  dilate_filter.set_volume(srcdst);
  
  structuringElement.SetRadius(painter_->get_vars()->get_int(name+"DilateRadius"));
  structuringElement.CreateStructuringElement();
  
  dilate_filter->SetKernel(structuringElement);
  dilate_filter->SetDilateValue(1);

  dilate_filter();

  if (copy_needed)
  {
    // Put the results back where they belong.
    VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_,
                        srcdst->nrrd_handle_, 1);
  }
}


void
ITKBinaryDilateErodeImageFilterTool::run_erode_filter(bool force_no_copy)
{
  const bool copy_needed =
    !force_no_copy && painter_->current_volume_->compute_label_mask() != 1;

  NrrdVolumeHandle srcdst = painter_->current_volume_;

  if (copy_needed)
  {
    // Make a temporary volume with only the one bit plane in it for ITK.
    NrrdDataHandle nrrdh =
      VolumeOps::create_clear_nrrd(painter_->current_volume_->nrrd_handle_,
                                   LabelNrrdType);

    const string name = "Unused";
    srcdst = new NrrdVolume(painter_, name, nrrdh, 1);

    VolumeOps::bit_copy(srcdst->nrrd_handle_, 1,
                        painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_);
  }

  const string name = "ITKBinaryDilateErodeImageFilterTool::";

  erode_filter.set_volume(srcdst);

  structuringElement.SetRadius(painter_->get_vars()->get_int(name+"ErodeRadius"));
  structuringElement.CreateStructuringElement();
  
  erode_filter->SetKernel(structuringElement);
  erode_filter->SetErodeValue(1);

  erode_filter();

  if (copy_needed)
  {
    // Put the results back where they belong.
    VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_,
                        srcdst->nrrd_handle_, 1);
  }
}


void
ITKBinaryDilateErodeImageFilterTool::run_dilate_erode_filter()
{
  const bool copy_needed =
    painter_->current_volume_->compute_label_mask() != 1;

  NrrdVolumeHandle srcdst = painter_->current_volume_;

  if (copy_needed)
  {
    // Make a temporary volume with only the one bit plane in it for ITK.
    NrrdDataHandle nrrdh =
      VolumeOps::create_clear_nrrd(painter_->current_volume_->nrrd_handle_,
                                   LabelNrrdType);

    const string name = "Unused";
    srcdst = new NrrdVolume(painter_, name, nrrdh, 1);

    VolumeOps::bit_copy(srcdst->nrrd_handle_, 1,
                        painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_);
  }

  run_dilate_filter(true);
  run_erode_filter(true);

  if (copy_needed)
  {
    // Put the results back where they belong.
    VolumeOps::bit_copy(painter_->current_volume_->nrrd_handle_,
                        painter_->current_volume_->label_,
                        srcdst->nrrd_handle_, 1);
  }
}


}
