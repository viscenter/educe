#include "UnwrapPlugin.h"
 
#include <sci_defs/insight_defs.h>

#include <string>
#include <Core/Events/BaseTool.h>
#include <Core/Datatypes/ITKDatatype.h>
#include <StandAlone/Apps/Seg3D/VolumeFilter.h>
#include <itkImageToImageFilter.h>
#include <itkCommand.h>
#include <itkOtsuThresholdImageFilter.h>

SET_PLUGIN_VERSION;

#define PI 3.14159
#define TORAD 1.0/PI

#define RADIAL_SAMPLES 360

#define SOBEL_THRESH 100
#define MAX_LAYERS 2

namespace SCIRun {

class ScrollUnwrapPlugin : public UnwrapPlugin {
	public:
		virtual std::string get_menu_string() const {
			return "Scroll Unwrapping";
		}
		virtual void menu_event() const {
			// printf("Hello from ExampleUnwrapPlugin\n");
		}
		BaseTool::propagation_state_e process_event(event_handle_t event) /*const*/ {
			// printf("Attempting to handle event inside plugin\n");
			// check for the FinishEvent signal generated by the start button
			if (dynamic_cast<FinishEvent *>(event.get_rep())) {
				if (!painter_->check_for_active_data_volume("Scroll Unwrapping filter"))
				{
					return STOP_E;
				}
				else if(!(painter_->mask_volume_.get_rep())) {
					painter_->set_status("Scroll Unwrapping filter requires a mask to be selected.");
					return STOP_E;
				}
			
				run_filter();
			}

			return CONTINUE_E;
		}
	private:
		CvPoint calc_ray_outer(float theta, CvPoint center)
		{
			CvPoint result;
			float hyp = (float)center.x;
			float dx = hyp * cos(theta);
			float dy = hyp * sin(theta);

			result.x = center.x - (int)dx;
			result.y = center.y - (int)dy;

			return result;
		}

		void radial_sample(int width, int height, char* data, char* ddata, IplImage *unwrapped, int slice)
		{
			IplImage *cvcast = cvCreateImageHeader(cvSize(width, height),
					IPL_DEPTH_8U, 1);
			cvcast->imageData = data;
			
			IplImage *cvcastd = cvCreateImageHeader(cvSize(width, height),
					IPL_DEPTH_8U, 1);
			cvcastd->imageData = ddata;

			//cvSaveImage("slicem.png",cvcast);
			//cvSaveImage("sliced.png",cvcastd);
			int cx = width/2;
			int cy = height/2;

			CvPoint center = cvPoint(cx,cy);

			unsigned char* linebuf;
			unsigned char* dlinebuf;
			for(int sample = 0; sample < RADIAL_SAMPLES; sample++) {
				float theta = ((float)sample)*((2.0*PI)/(float)RADIAL_SAMPLES);
				CvPoint outer = calc_ray_outer(theta, center);

				// printf("%g:\t%d,%d\n", theta*(180.0/PI), outer.x, outer.y);
				cvClipLine(cvSize(width, height), &outer, &center);
				int linesize = abs(center.x-outer.x)+abs(center.y-outer.y)+1;
				
				linebuf = (unsigned char*)malloc(linesize);
				dlinebuf = (unsigned char*)malloc(linesize);
				
				cvSampleLine(cvcast,outer,center,linebuf,4);
				
				cvSampleLine(cvcastd,outer,center,dlinebuf,4);
				
				IplImage *castline = cvCreateImageHeader(cvSize(linesize,1), IPL_DEPTH_8U, 1);
				castline->imageData = (char*)linebuf;

				IplImage *dcastline = cvCreateImageHeader(cvSize(linesize,1), IPL_DEPTH_8U, 1);
				dcastline->imageData = (char*)dlinebuf;
				/*
				IplImage *sobel = cvCreateImage(cvSize(linesize,1), IPL_DEPTH_8U, 1);

				cvSobel(castline, sobel, 1, 0, 3);
				*/

				int layer = 0;
				for(int i = 0; (i < linesize) && (layer < MAX_LAYERS); i++) {
					// printf(" %d,", (int)cvGetReal1D(sobel,i));
					if((int)cvGetReal1D(castline,i) > 0) {
						int max = 0, max_i = 0;
						int min = 255, min_i = 0;
						int j = i;
						i -= 2;
						for(; (i < linesize) && (j < linesize); i++, j++) {
							int maskval = (int)cvGetReal1D(castline,j);
							int curval = (int)cvGetReal1D(dcastline,i);
							if(maskval == 0) break;
							if(curval > max) {
								max = curval;
								max_i = i;
							}
							if(curval < min) {
								min = curval;
								min_i = i;
							}
						}
						cvSetReal2D(unwrapped,slice,(layer*RADIAL_SAMPLES)+sample,cvGetReal1D(dcastline,max_i));
						// printf("%d\t",max);
						layer++;
					}
				}
				// printf("\n");
			
				/*	
				char filename[] = "line000.png";
				sprintf(filename,"line%03d.png",(int)(theta*(180.0/PI)));
				cvSaveImage(filename,sobel);
				*/

				cvReleaseImageHeader(&castline);
				cvReleaseImageHeader(&dcastline);
				// cvReleaseImage(&sobel);

				free(linebuf);
				free(dlinebuf);
			}
			cvReleaseImageHeader(&cvcast);
			cvReleaseImageHeader(&cvcastd);
		}
		virtual void run_filter() {	
			printf("Scroll Unwrapping run\n");

			painter_->set_status("Running scroll unwrapping filter.");

			NrrdDataHandle source_label = painter_->mask_volume_->nrrd_handle_;
			NrrdDataHandle source_data = painter_->current_volume_->nrrd_handle_;


			const label_type mlabel = painter_->mask_volume_->label_;

			const size_t labelsize = VolumeOps::nrrd_elem_count(source_label);
			const size_t datasize = VolumeOps::nrrd_elem_count(source_data);

			ASSERT(labelsize == datasize);
			ASSERT(source_data->nrrd_->type == nrrdTypeFloat);
			ASSERT(source_label->nrrd_->type == LabelNrrdType);

			NrrdDataHandle masked = VolumeOps::create_clear_nrrd(source_data,
					nrrdTypeFloat);

			float *dst = (float*)masked->nrrd_->data;
			float *src = (float*)source_data->nrrd_->data;
			label_type *labeld = (label_type*)source_label->nrrd_->data;
			for(size_t i = 0; i < datasize; ++i, ++dst, ++labeld, ++src) {
				if((*labeld & mlabel)) {
					*dst = *src;
				}
			}
			
			painter_->update_progress(25);

			printf("Axis dimensions: %d x %d x %d\n",masked->nrrd_->axis[1].size,
					masked->nrrd_->axis[2].size,masked->nrrd_->axis[3].size);

			NrrdRange *range = nrrdRangeNewSet(masked->nrrd_,0);
			printf("min: %g\tmax: %g\n", range->min, range->max);
			Nrrd *mquantized = nrrdNew();
			
			nrrdQuantize(mquantized,masked->nrrd_,range,8);

			nrrdRangeNix(range);

			range = nrrdRangeNewSet(source_data->nrrd_,0);
			printf("min: %g\tmax: %g\n", range->min, range->max);
			Nrrd *dquantized = nrrdNew();
			
			nrrdQuantize(dquantized,source_data->nrrd_,range,8);
			//nrrdSave("quantized.nrrd",masked->nrrd_,NULL); 

			nrrdRangeNix(range);

			painter_->update_progress(50);

			int width = mquantized->axis[1].size,
				height = mquantized->axis[2].size,
				slices = mquantized->axis[3].size;

			IplImage *unwrapped = cvCreateImage(cvSize(RADIAL_SAMPLES*MAX_LAYERS, slices), IPL_DEPTH_8U, 1);
	
			for(int i = 0; i < slices; i++) {
				radial_sample(width, height, ((char*)(mquantized->data))+(width * height * i), ((char*)(dquantized->data))+(width * height * i), unwrapped, i);
				painter_->update_progress(((float)i/(float)slices)*100);
			}

			init_window(unwrapped);
			printf("Init'd win\n");
			
			cvSaveImage("unwrapped.png",unwrapped);
			//cvReleaseImage(&unwrapped);

			nrrdNuke(mquantized);
			nrrdNuke(dquantized);

			painter_->update_progress(100);
			painter_->extract_all_window_slices();
			painter_->redraw_all();
			
			painter_->hide_tool_panel();
		}
};

EXPORT_CREATE_FUNCTION(UnwrapPlugin, ScrollUnwrapPlugin)
EXPORT_DELETE_FUNCTION(UnwrapPlugin, ScrollUnwrapPlugin)

}
