//
//  For more information, please see: http://software.sci.utah.edu
//
//  The MIT License
//
//  Copyright (c) 2006 Scientific Computing and Imaging Institute,
//  University of Utah.
//
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
//  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.
//
//    File   : Histogram.cc
//    Author : McKay Davis
//    Date   : Tue Jun 27 12:59:23 2006

#include <Core/Datatypes/NrrdToITK.h>
#include <Core/Skinner/Variables.h>
#include <Core/Skinner/Histogram.h>
#include <Core/Events/EventManager.h>
#include <Core/Events/LoadVolumeEvent.h>
#include <Core/Geom/TextureObj.h>
#include <Core/Geometry/Transform.h>
#include <Core/Util/FileUtils.h>
#include <Core/Util/Environment.h>
#include <Core/Containers/StringUtil.h>
#include <Core/Math/MiscMath.h>
#include <Core/Math/MinMax.h>
#include <sci_gl.h>

namespace SCIRun {
namespace Skinner {

class ComputeHistogram : public Runnable
{
public:
  ComputeHistogram(NrrdDataHandle data, unsigned int time) :
    data_(data),
    time_(time)
  {}
  virtual ~ComputeHistogram() {}

  virtual void run()
  {
    NrrdDataHandle histo = Histogram::GenerateHistogram(data_);
    event_handle_t uhe = new UpdateHistogramEvent(0, histo, time_);
    EventManager::add_event(uhe);
  }

  NrrdDataHandle data_;
  unsigned int time_;
};


template <class T>
static void
compute_gm_histo(T *nindata,
                 const int ni, const int nj, const int nk,
                 float *histo, const size_t hi, const size_t hj,
                 Transform &transform,
                 double vmin, double vmax,
                 double invdatascale)
{
  int i, j, k;
  const unsigned int nji = nj * ni;

  for (k = 0; k < nk; k++)
  {
    const int k0 = Max(k-1, 0);
    const int k1 = Min(k+1, nk-1);
    for (j = 0; j < nj; j++)
    {
      const int j0 = Max(j-1, 0);
      const int j1 = Min(j+1, nj-1);
      for (i = 0; i < ni; i++)
      {
        const int i0 = Max(i-1, 0);
        const int i1 = Min(i+1, ni-1);

        const double x0 = nindata[k * nji + j * ni + i0];
        const double x1 = nindata[k * nji + j * ni + i1];
        const double y0 = nindata[k * nji + j0 * ni + i];
        const double y1 = nindata[k * nji + j1 * ni + i];
        const double z0 = nindata[k0 * nji + j * ni + i];
        const double z1 = nindata[k1 * nji + j * ni + i];

        const Vector g((x1 - x0)*invdatascale,
                       (y1 - y0)*invdatascale,
                       (z1 - z0)*invdatascale);
        const Vector gradient = transform.project_normal(g);
        // TODO: 1.75 is an arbitrary number that probably looked good
        // on the tooth dataset.  It is hard coded into the VolShader
        // and should go away now.
        const double gm = gradient.length() * 1.75;
        // Gradient min is always 0 and gradient max is always 1.0.
        // This comes from them being texture coordinates as generated by
        // the shader.
        const size_t gmi = size_t(gm * hj);

        const double v = nindata[k * nji + j * ni + i];
        const size_t vi = size_t((v - vmin) * hi / vmax);

        if (vi < hi && gmi < hj)
          histo[gmi * hi + vi]++;
      }
    }
  }
}


NrrdDataHandle
Histogram::BuildJHistoDirectly(NrrdDataHandle in)
{
  NrrdDataHandle gmout_handle;

  Nrrd *nin = in->nrrd_;

  if (!(nin->dim == 3 || nin->dim == 4))
  {
    cerr<<("Input nrrd must be three or four dimensional.");
    return NULL;
  }

  size_t gmsize[NRRD_DIM_MAX];

  // Create a local array of axis sizes, so we can allocate the output Nrrd
  for (size_t dim=0; dim < nin->dim; dim++)
  {
    gmsize[dim] = 256;
  }

  // Allocate the nrrd's data, set the size of each axis
  Nrrd *gmout = nrrdNew();
  nrrdAlloc_nva(gmout, nrrdTypeFloat, 2, gmsize);

  const int off = (nin->dim == 4)?1:0;
  const NrrdAxisInfo &axis0 = nin->axis[off+0];
  const NrrdAxisInfo &axis1 = nin->axis[off+1];
  const NrrdAxisInfo &axis2 = nin->axis[off+2];

  // Build the transform here.
  Transform transform;
  string trans_str;
  // See if it's stored in the nrrd first.
  if (in->get_property("Transform", trans_str) &&
      trans_str != "Unknown")
  {
    double t[16];
    int old_index=0, new_index=0;
    for(int i=0; i<16; i++)
    {
      new_index = trans_str.find(" ", old_index);
      string temp = trans_str.substr(old_index, new_index-old_index);
      old_index = new_index+1;
      string_to_double(temp, t[i]);
    }
    transform.set(t);
  }
  else
  {
    transform.load_identity();
    if (axis0.min == AIR_NAN || axis0.max == AIR_NAN ||
        axis1.min == AIR_NAN || axis1.max == AIR_NAN ||
        axis2.min == AIR_NAN || axis2.max == AIR_NAN)
    {
      if (axis0.spacing == AIR_NAN ||
          axis1.spacing == AIR_NAN ||
          axis2.spacing == AIR_NAN)
      {
        cerr<<("No spacing available, using unit spacing.");
        cerr<<("Use UnuAxisInfo or similar to change spacing if desired.");

        const Vector scale(axis0.size - 1.0,
                           axis1.size - 1.0,
                           axis2.size - 1.0);
        transform.pre_scale(scale);
      }
      else
      {
        const Vector scale((axis0.size - 1.0) * axis0.spacing,
                           (axis1.size - 1.0) * axis1.spacing,
                           (axis2.size - 1.0) * axis2.spacing);
        transform.pre_scale(scale);
      }
    }
    else
    {
      // Reconstruct the axis aligned transform.
      const Point nmin(axis0.min, axis1.min, axis2.min);
      const Point nmax(axis0.max, axis1.max, axis2.max);
      transform.pre_scale(nmax - nmin);
      transform.pre_translate(nmin.asVector());
    }
  }

  // Add the matrix size into the canonical transform.
  transform.post_scale(Vector(1.0 / (axis0.size - 1.0),
                              1.0 / (axis1.size - 1.0),
                              1.0 / (axis2.size - 1.0)));

  // Compute the gradient magnitude, dispatch based upon data type.
  float *histogram = (float *)(gmout->data);
  const int ni = axis0.size;
  const int nj = axis1.size;
  const int nk = axis2.size;
  const double vmin = 0.0;
  const double vmax = 256.0;
  if (nin->type == nrrdTypeChar)
  {
    compute_gm_histo((char *)nin->data, ni, nj, nk,
                     histogram, 256, 256, transform,
                     vmin, vmax, 1.0 / 255.0);
  }
  else if (nin->type == nrrdTypeUChar)
  {
    compute_gm_histo((unsigned char *)nin->data, ni, nj, nk,
                     histogram, 256, 256, transform,
                     vmin, vmax, 1.0 / 255.0);
  }
#if 0
  else if (nin->type == nrrdTypeShort)
  {
    compute_data((short *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
  else if (nin->type == nrrdTypeUShort)
  {
    compute_data((unsigned short *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
  else if (nin->type == nrrdTypeInt)
  {
    compute_data((int *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
  else if (nin->type == nrrdTypeUInt)
  {
    compute_data((unsigned int *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
  else if (nin->type == nrrdTypeFloat)
  {
    compute_data((float *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
  else if (nin->type == nrrdTypeDouble)
  {
    compute_data((double *)nin->data,
                 gmoutdata, ni, nj, nk, transform);
  }
#endif
  else
  {
    cerr<<("Unsupported input type.");
    return NULL;
  }

  for (size_t i = 0; i < 256*256;i++)
  {
    histogram[i] = log(histogram[i] + 1.0);
  }

  // Create SCIRun data structure wrapped around gmout
  gmout_handle = scinew NrrdData(gmout);

  // Copy the properties
  gmout_handle->copy_properties(in.get_rep());

  return gmout_handle;
}


NrrdDataHandle
Histogram::UnuJhisto(NrrdDataHandle in0, NrrdDataHandle in1)
{
  size_t bin[2];
  bin[0] = 256;
  bin[1] = 256;

  Nrrd *nrrds_array[2];
  nrrds_array[0] = in0->nrrd_;
  nrrds_array[1] = in1->nrrd_;

  NrrdRange *range[2];
  range[0] = nrrdRangeNew(AIR_NAN, AIR_NAN);
  range[1] = nrrdRangeNew(AIR_NAN, AIR_NAN);

  int clamp[2];
  clamp[0] = 0;
  clamp[1] = 0;

  Nrrd *nout = nrrdNew();

  if (nrrdHistoJoint(nout, nrrds_array, range, 2, 0,
                     bin, nrrdTypeFloat, clamp))
  {
    char *err = biffGetDone(NRRD);
    cerr<<"Error performing Unu Jhisto: " <<  err<<endl;
    free(err);
    return NULL;
  }

  NrrdDataHandle nout_handle = scinew NrrdData(nout);

  if (airIsNaN(range[0]->min) || airIsNaN(range[0]->max))
  {
    NrrdRange *minmax = nrrdRangeNewSet(nrrds_array[0],
                                        nrrdBlind8BitRangeFalse);
    if (airIsNaN(range[0]->min)) range[0]->min = minmax->min;
    if (airIsNaN(range[0]->max)) range[0]->max = minmax->max;
    nrrdRangeNix(minmax);
  }
  nrrdKeyValueAdd(nout_handle->nrrd_, "jhisto_nrrd0_min",
                  to_string(range[0]->min).c_str());
  nrrdKeyValueAdd(nout_handle->nrrd_, "jhisto_nrrd0_max",
                  to_string(range[0]->max).c_str());

  nrrdRangeNix(range[0]);
  nrrdRangeNix(range[1]);

  return nout_handle;
}


NrrdDataHandle
Histogram::Unu2op(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;
  NrrdDataHandle nrrd_handle1 = in;

  Nrrd *nin = 0;
  Nrrd *nout = nrrdNew();
  nin = nrrd_handle1->nrrd_;

  NrrdIter *in1 = nrrdIterNew();
  NrrdIter *in2 = nrrdIterNew();

  nrrdIterSetOwnNrrd(in1, nin);
  nrrdIterSetValue(in2, 1.0);

  if (nrrdArithIterBinaryOp(nout, nrrdBinaryOpAdd, in1, in2)) {
    char *err = biffGetDone(NRRD);
    cerr<<"Error performing 2op to nrrd: "<< err<<endl;
    free(err);
  }

  nrrdKeyValueCopy(nout, nin);

  nout_handle = scinew NrrdData(nout);
  return nout_handle;

}


NrrdDataHandle
Histogram::Unu1op(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;

  NrrdDataHandle nrrd_handle = in;

  Nrrd *nin = nrrd_handle->nrrd_;
  Nrrd *nout = nrrdNew();
  if (nrrdArithUnaryOp(nout,nrrdUnaryOpLog, nin))
  {
    char *err = biffGetDone(NRRD);
    cerr<<(string("Error performing 1op to nrrd: ") + err);
    free(err);
    return NULL;
  }

  nrrdKeyValueCopy(nout, nin);

  nout_handle = scinew NrrdData(nout);
  return nout_handle;
}


NrrdDataHandle
Histogram::UnuHeq(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;

  NrrdDataHandle nrrd_handle = in;

  Nrrd *nin = nrrd_handle->nrrd_;
  Nrrd *nout = nrrdNew();

  if (nrrdHistoEq(nout, nin, NULL, 3000, 1, 1.0))
  {
    char *err = biffGetDone(NRRD);
    cerr<<(string("Error creating Histogram Equalizing nrrd: ") + err);
    free(err);
  }

  nrrdKeyValueCopy(nout, nin);

  nout_handle = scinew NrrdData(nout);
  return nout_handle;
}


NrrdDataHandle
Histogram::UnuGamma(NrrdDataHandle in, double gamma)
{
  NrrdDataHandle nout_handle;

  NrrdDataHandle nrrd_handle = in;

  Nrrd *nin = nrrd_handle->nrrd_;
  Nrrd *nout = nrrdNew();

  NrrdRange *range = NULL;

  double min = AIR_NAN, max = AIR_NAN;

  nrrdRangeNew(min, max);
  nrrdRangeSafeSet(range, nin, nrrdBlind8BitRangeState);

  if (nrrdArithGamma(nout, nin, range, gamma)) {
    char *err = biffGetDone(NRRD);
    cerr<<(string("Error creating peforming unu gamma on nrrd: ") + err);
    free(err);
  }

  nrrdKeyValueCopy(nout, nin);

  nout_handle = scinew NrrdData(nout);
  return nout_handle;
}


NrrdDataHandle
Histogram::UnuQuantize(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;
  NrrdDataHandle nrrdH = in;

  NrrdRange *range =
    nrrdRangeNewSet(nrrdH->nrrd_, nrrdBlind8BitRangeState);
  const double minf = range->min;
  const double maxf = range->max;
  nrrdRangeNix(range);

  const int nbits = 8;

  Nrrd *nin = nrrdH->nrrd_;

  //      cerr <<("Quantizing -- min=" + to_string(minf) +
  // " max=" + to_string(maxf) + " nbits=" + to_string(nbits) +"\n");
  NrrdRange *range1 = nrrdRangeNew(minf, maxf);
  NrrdData *nrrd = scinew NrrdData;
  if (nrrdQuantize(nrrd->nrrd_, nin, range1, nbits))
  {
    char *err = biffGetDone(NRRD);
    cerr<<(string("Trouble quantizing: ") + err);
    free(err);
    return NULL;
  }

  nrrdKeyValueCopy(nrrd->nrrd_, nin);
  nout_handle = nrrd;
  return nout_handle;
}


NrrdDataHandle
Histogram::UnuQuantize16(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;
  NrrdDataHandle nrrdH = in;

  NrrdRange *range =
    nrrdRangeNewSet(nrrdH->nrrd_, nrrdBlind8BitRangeState);
  const double minf = range->min;
  const double maxf = range->max;
  nrrdRangeNix(range);

  const int nbits = 16;

  Nrrd *nin = nrrdH->nrrd_;

  //      cerr <<("Quantizing -- min=" + to_string(minf) +
  // " max=" + to_string(maxf) + " nbits=" + to_string(nbits) +"\n");
  NrrdRange *range1 = nrrdRangeNew(minf, maxf);
  NrrdData *nrrd = scinew NrrdData;
  if (nrrdQuantize(nrrd->nrrd_, nin, range1, nbits))
  {
    char *err = biffGetDone(NRRD);
    cerr<<(string("Trouble quantizing: ") + err);
    free(err);
    return NULL;
  }

  nrrdKeyValueCopy(nrrd->nrrd_, nin);
  nout_handle = nrrd;
  return nout_handle;
}


NrrdDataHandle
Histogram::GenerateHistogram(NrrdDataHandle in)
{
  NrrdDataHandle nout_handle;

  nout_handle = BuildJHistoDirectly(in);
  nout_handle = UnuHeq(nout_handle);

  return UnuQuantize(nout_handle);
}


Histogram::Histogram(Variables *variables) :
  Parent(variables),
  histo_nrrd_(0),
  tex_(0),
  filename_(variables, "filename"),
  opacity_(variables, "Histogram::opacity", 1.0),
  gamma_(variables, "Histogram::gamma", 1.0),
  old_gamma_(1.0),
  current_time_(0)
{
  REGISTER_CATCHER_TARGET(Histogram::redraw);
}


Histogram::~Histogram()
{
}


BaseTool::propagation_state_e
Histogram::redraw(event_handle_t &)
{
  if (tex_) {
    glMatrixMode(GL_TEXTURE);
    glPushMatrix();
    glLoadIdentity();
    CHECK_OPENGL_ERROR();

    Point coords[4];
    const RectRegion &region = get_region();

    float tw = 1.0;
    float th = 1.0;

    float tex_coords[8] = {0, Floor(th)-th,
                           tw, Floor(th)-th,
                           tw, Floor(th),
                           0.0, Floor(th) };

    coords[0] = Point(region.x1(), region.y1(), 0.0);
    coords[1] = Point(region.x2(), region.y1(), 0.0);
    coords[2] = Point(region.x2(), region.y2(), 0.0);
    coords[3] = Point(region.x1(), region.y2(), 0.0);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    tex_->set_color(1.0, 1.0, 1.0, opacity_);
    tex_->draw(4, coords, tex_coords);
    glMatrixMode(GL_TEXTURE);
    glPopMatrix();
  }

  return CONTINUE_E;
}


BaseTool::propagation_state_e
Histogram::process_event(event_handle_t &event)
{
  UpdateHistogramEvent *uhe =
    dynamic_cast<UpdateHistogramEvent *>(event.get_rep());
  if (uhe) {
    if (uhe->get_data().get_rep()) {
      static unsigned int time = 0;
      ComputeHistogram *ch = new ComputeHistogram(uhe->get_data(), time++);
      Thread *chthread = new Thread(ch, "Histogram Computer");
      chthread->detach();
      return Parent::process_event(event);
    }
    else
    {
      histo_nrrd_ = uhe->get_histo();
      if (histo_nrrd_.get_rep() && uhe->get_time() >= current_time_)
      {
        nrrdAxesInsert(histo_nrrd_->nrrd_, histo_nrrd_->nrrd_, 0);
        current_time_ = uhe->get_time();
        if (tex_)
        {
          tex_->set_nrrd(histo_nrrd_);
          tex_->set_dirty();
          old_gamma_ = 1.0;
        }
      }
    }
  }

  if (histo_nrrd_.get_rep() && (!tex_ || old_gamma_ != gamma_())) {
    old_gamma_ = gamma_;
    NrrdDataHandle texn;
    texn = UnuGamma(histo_nrrd_, gamma_);
    texn = UnuQuantize(texn);

    //        if (tex_) delete tex_;
    // TODO:  Memory leak here when loading multiple volumes
    // because tex_ must be deleted in GL context.
    tex_ = new TextureObj(texn);
  }

  return Parent::process_event(event);
}


} // namespace Skinner
} // namespace SCIRun
