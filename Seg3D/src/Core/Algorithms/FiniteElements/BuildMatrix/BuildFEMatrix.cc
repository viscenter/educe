/*
   For more information, please see: http://software.sci.utah.edu

   The MIT License

   Copyright (c) 2004 Scientific Computing and Imaging Institute,
   University of Utah.

   
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/

#include <Core/Algorithms/FiniteElements/BuildMatrix/BuildFEMatrix.h>

#include <Core/Datatypes/DenseMatrix.h>
#include <Core/Datatypes/SparseRowMatrix.h>
#include <Core/Datatypes/MatrixOperations.h>

#include <Core/Thread/Barrier.h>
#include <Core/Thread/Thread.h>

#include <Core/Geometry/Point.h>
#include <Core/Geometry/Tensor.h>


#include <string>
#include <vector>
#include <algorithm>

namespace SCIRunAlgo {

using namespace SCIRun;

// Helper class

class FEMBuilder
{
  public:

    // Constructor needed as Barrier needs to have name
    FEMBuilder(AlgoBase* algo) :
      ref_cnt(0),
      algo_(algo),
      barrier_("FEMBuilder Barrier")
    {
    }

    // Local entry function for none pure function.
    bool build_matrix(FieldHandle input, 
                      MatrixHandle ctable,
                      MatrixHandle& output);
    int ref_cnt;

  private:

    AlgoBase* algo_;
    Barrier barrier_;
    
    VMesh* mesh_;
    VField *field_;

    MatrixHandle fematrixhandle_;
    SparseRowMatrix* fematrix_;

    // num processors
    int numprocessors_;

    std::vector<bool> success_;
    
    Matrix::index_type* rows_;
    Matrix::index_type* allcols_;
    std::vector<Matrix::index_type> colidx_;

    Matrix::index_type domain_dimension;

    Matrix::index_type local_dimension_nodes;
    Matrix::index_type local_dimension_add_nodes;
    Matrix::index_type local_dimension_derivatives;
    Matrix::index_type local_dimension;

    Matrix::index_type global_dimension_nodes;
    Matrix::index_type global_dimension_add_nodes;
    Matrix::index_type global_dimension_derivatives;
    Matrix::index_type global_dimension; 

    // A copy of the tensors list that was generated by SetConductivities
    bool use_tensor_;
    std::vector<std::pair<string, Tensor> > tensors_;

    bool use_scalars_;
    std::vector<std::pair<string, double> > scalars_;

    // Entry point for the parallel version
    void parallel(int proc);
      
  private:

    inline void add_lcl_gbl(Matrix::index_type row, const std::vector<Matrix::index_type> &cols, const std::vector<double> &lcl_a)
    {
      for (size_t i = 0; i < lcl_a.size(); i++) fematrix_->add(row, cols[i], lcl_a[i]);
    }

  private:

    void create_numerical_integration(std::vector<VMesh::coords_type > &p,
                                      std::vector<double> &w,
                                      std::vector<std::vector<double> > &d);
    bool build_local_matrix(VMesh::Elem::index_type c_ind,
                            Matrix::index_type row, 
                            std::vector<double> &l_stiff,
                            std::vector<VMesh::coords_type> &p,
                            std::vector<double> &w,
                            std::vector<std::vector<double> >  &d);
    bool build_local_matrix_regular(VMesh::Elem::index_type c_ind,
                                    Matrix::index_type row, 
                                    std::vector<double> &l_stiff,
                                    std::vector<VMesh::coords_type> &p,
                                    std::vector<double> &w,
                                    std::vector<std::vector<double> >  &d, 
                                    std::vector<std::vector<double> > &precompute);
    bool setup();
  
};


bool
FEMBuilder::build_matrix(FieldHandle input, 
                         MatrixHandle ctable,
                         MatrixHandle& output)
{
  // Get virtual interface to data
  field_ = input->vfield();
  mesh_  = input->vmesh();

  // Determine the number of processors to use:

  numprocessors_ = Thread::numProcessors();
  int numproc = algo_->get_int("num_processors");
  if (numproc > 0) { numprocessors_ = numproc; }
  
  // If we have the Conductivity property use it, if not we assume the values on
  // the data to be the actual tensors.
  field_->get_property("conductivity_table",tensors_);
  
  // We added a second system of adding a conductivity table, using a matrix
  // Convert that matrix into the conducivity table
  if (ctable.get_rep())
  {
    tensors_.clear();
    DenseMatrix* mat = ctable->dense();
    MatrixHandle temphandle = mat;
    // Only if we can convert it into a denso matrix, otherwise skip it
    if (mat)
    {
      double* data = mat->get_data_pointer();
      Matrix::size_type m = mat->nrows();
      Matrix::size_type n = mat->ncols();
      Tensor T; 

      // Case the table has isotropic conductivities
      if (mat->ncols() == 1)
      {
        for (Matrix::size_type p=0; p<m;p++)
        {
          // Set the diagonals to the proper version.
          T.mat_[0][0] = data[p*n+0];
          T.mat_[1][0] = 0.0;
          T.mat_[2][0] = 0.0;
          T.mat_[0][1] = 0.0;
          T.mat_[1][1] = data[p*n+0];
          T.mat_[2][1] = 0.0;
          T.mat_[0][2] = 0.0;
          T.mat_[1][2] = 0.0;
          T.mat_[2][2] = data[p*n+0];
          tensors_.push_back(std::pair<string, Tensor>("",T));
        }
      }
       
      // Use our compressed way of storing tensors 
      if (mat->ncols() == 6)
      {
        for (Matrix::size_type p=0; p<m;p++)
        {
          T.mat_[0][0] = data[0+p*n];
          T.mat_[1][0] = data[1+p*n];
          T.mat_[2][0] = data[2+p*n];
          T.mat_[0][1] = data[1+p*n];
          T.mat_[1][1] = data[3+p*n];
          T.mat_[2][1] = data[4+p*n];
          T.mat_[0][2] = data[2+p*n];
          T.mat_[1][2] = data[4+p*n];
          T.mat_[2][2] = data[5+p*n];
          tensors_.push_back(std::pair<string, Tensor>("",T));
        }
      }

      // Use the full symmetric tensor. We will make the tensor symmetric here.
      if (mat->ncols() == 9)
      {
        for (Matrix::size_type p=0; p<m;p++)
        {
          T.mat_[0][0] = data[0+p*n];
          T.mat_[1][0] = data[1+p*n];
          T.mat_[2][0] = data[2+p*n];
          T.mat_[0][1] = data[1+p*n];
          T.mat_[1][1] = data[4+p*n];
          T.mat_[2][1] = data[5+p*n];
          T.mat_[0][2] = data[2+p*n];
          T.mat_[1][2] = data[5+p*n];
          T.mat_[2][2] = data[8+p*n];
          tensors_.push_back(std::pair<string, Tensor>("",T));
        }
      }
    }
  }
  
  success_.resize(numprocessors_,true);

  // Start the multi threaded FE matrix builder.
  Thread::parallel(this, &FEMBuilder::parallel, numprocessors_);
  for (size_t j=0; j<success_.size(); j++)
  {
    if (success_[j] == false) return (false);
  }

	// Make sure it is symmetric
	
  if (algo_->get_bool("force_symmetry"))
  {
    // Make sure the matrix is fully symmetric, this compensates for round off
    // errors
    MatrixHandle trans = fematrixhandle_->transpose();
    output = 0.5*(trans+fematrixhandle_);
  }
  else
  {
    // Assume that the builder did a good job and the matrix is numerically almost
    // symmetric
    output = fematrixhandle_;
  }
  
  return (true);
}


void 
FEMBuilder::
create_numerical_integration(std::vector<VMesh::coords_type> &p,
                             std::vector<double> &w,
                             std::vector<std::vector<double> > &d)
{
  int int_basis = 1;
  if (mesh_->is_quad_element() || 
      mesh_->is_hex_element() || 
      mesh_->is_prism_element())
  {
    int_basis = 2;
  }
  mesh_->get_gaussian_scheme(p,w,int_basis);
  d.resize(p.size());
  for (size_t j=0; j<p.size();j++)
    mesh_->get_derivate_weights(p[j],d[j],1);
    
}


//! build line of the local stiffness matrix

bool
FEMBuilder::
build_local_matrix(VMesh::Elem::index_type c_ind,
                   Matrix::index_type row, std::vector<double> &l_stiff,
                   std::vector<VMesh::coords_type > &p,
                   std::vector<double> &w,
                   std::vector<std::vector<double> >  &d)
{
  Tensor T;
  
  if (tensors_.size() == 0)
  {
    field_->get_value(T,c_ind);
  }
  else
  {
    int tensor_index;
    field_->get_value(tensor_index,c_ind);
    T = tensors_[tensor_index].second;
  }

  double Ca = T.mat_[0][0];
  double Cb = T.mat_[0][1];
  double Cc = T.mat_[0][2];
  double Cd = T.mat_[1][1];
  double Ce = T.mat_[1][2];
  double Cf = T.mat_[2][2];

  if ((Ca==0)&&(Cb==0)&&(Cc==0)&&(Cd==0)&&(Ce==0)&&(Cf==0))
  {
    for (int j = 0; j<local_dimension; j++)
    {
      l_stiff[j] = 0.0;
    }
  }
  else
  {
    for(int i=0; i<local_dimension; i++)
      l_stiff[i] = 0.0;

    int local_dimension2=2*local_dimension;

    // These calls are direct lookups in the base of the VMesh
    // The compiler should optimize these well
    double vol = mesh_->get_element_size();
    const int dim = mesh_->dimensionality();

    ASSERT(dim >=1 && dim <=3);
    for (size_t i = 0; i < d.size(); i++)
    {
      double Ji[9];
      // Call to virtual interface, this should be one internal call
      double detJ = mesh_->inverse_jacobian(p[i],c_ind,Ji);   
      
      // If Jacobian is negative there is a problem with the mesh
      if (detJ <= 0.0)
      {
        algo_->error("Mesh has elements with negative jacobians, check the order of the nodes that define an element");
        return (false);
      }
      
      // Volume associated with the local Gaussian Quadrature point:
      // weightfactor * Volume Unit element * Volume ratio (real element/unit element)
      detJ*=w[i]*vol;
    
      // Build local stiffness matrix
      // Get the local derivatives of the basis functions in the basis element
      // They are all the same and are thus precomputed in matrix d
      const double *Nxi = &d[i][0];
      const double *Nyi = &d[i][local_dimension];
      const double *Nzi = &d[i][local_dimension2];
      // Gradients associated with the node we are calculating
      const double &Nxip = Nxi[row];
      const double &Nyip = Nyi[row];
      const double &Nzip = Nzi[row];
      // Calculating gradient shape function * inverse Jacobian * volume scaling factor
      const double uxp = detJ*(Nxip*Ji[0]+Nyip*Ji[1]+Nzip*Ji[2]);
      const double uyp = detJ*(Nxip*Ji[3]+Nyip*Ji[4]+Nzip*Ji[5]);
      const double uzp = detJ*(Nxip*Ji[6]+Nyip*Ji[7]+Nzip*Ji[8]);
      // Matrix multiplication with conductivity tensor :
      const double uxyzpabc = uxp*Ca+uyp*Cb+uzp*Cc;
      const double uxyzpbde = uxp*Cb+uyp*Cd+uzp*Ce;
      const double uxyzpcef = uxp*Cc+uyp*Ce+uzp*Cf;
    
      // The above is constant for this node. Now multiply with the weight function
      // We assume the weight factors are the same as the local gradients 
      // Galerkin approximation:
       
      for (int j = 0; j<local_dimension; j++)
      {
        const double &Nxj = Nxi[j];
        const double &Nyj = Nyi[j];
        const double &Nzj = Nzi[j];
    
        // Matrix multiplication Gradient with inverse Jacobian:
        const double ux = Nxj*Ji[0]+Nyj*Ji[1]+Nzj*Ji[2];
        const double uy = Nxj*Ji[3]+Nyj*Ji[4]+Nzj*Ji[5];
        const double uz = Nxj*Ji[6]+Nyj*Ji[7]+Nzj*Ji[8];
        
        // Add everything together into one coeffiecient of the matrix
        l_stiff[j] += ux*uxyzpabc+uy*uxyzpbde+uz*uxyzpcef;
      }
    }
  }
  
  return (true);
}


bool 
FEMBuilder
::build_local_matrix_regular(VMesh::Elem::index_type c_ind,
                             Matrix::index_type row, std::vector<double> &l_stiff,
                             std::vector<VMesh::coords_type> &p,
                             std::vector<double> &w,
                             std::vector<std::vector<double> >  &d,
                             std::vector<std::vector<double> > &precompute)
{
  Tensor T;
  
  if (tensors_.size() == 0)
  {
    // Call to virtual interface. Get the tensor value. Actually this call relies
    // on the automatic casting feature of the virtual interface to convert scalar
    // values into a tensor.
    field_->get_value(T,c_ind);
  }
  else
  {
    int tensor_index;
    field_->get_value(tensor_index,c_ind);
    T = tensors_[tensor_index].second;
  }
  
  double Ca = T.mat_[0][0];
  double Cb = T.mat_[0][1];
  double Cc = T.mat_[0][2];
  double Cd = T.mat_[1][1];
  double Ce = T.mat_[1][2];
  double Cf = T.mat_[2][2];

  if ((Ca==0)&&(Cb==0)&&(Cc==0)&&(Cd==0)&&(Ce==0)&&(Cf==0))
  {
    for (int j = 0; j<local_dimension; j++)
    {
      l_stiff[j] = 0.0;
    }
  }
  else
  {
  
    if (precompute.size() == 0)
    {
      precompute.resize(d.size());
      for (int m=0; m < static_cast<int>(d.size()); m++)
      {
        precompute[m].resize(10);
      }
      
      for(int i=0; i<local_dimension; i++)
        l_stiff[i] = 0.0;

      int local_dimension2=2*local_dimension;

      double vol = mesh_->get_element_size();
      //const int dim = mesh_->dimensionality();

      for (size_t i = 0; i < d.size(); i++)
      {
        std::vector<double>& pc = precompute[i];

        double Ji[9];
        double detJ = mesh_->inverse_jacobian(p[i],c_ind,Ji);           
                   
        // Volume elements can return negative determinants if the order of elements
        // is put in a different order
        // TODO: It seems to be that a negative determinant is not necessarily bad, 
        // we should be more flexible on thiis point
        if (detJ <= 0.0) 
        {
          algo_->error("Mesh has elements with negative jacobians, check the order of the nodes that define an element");
          return (false);
        }
        // Volume associated with the local Gaussian Quadrature point:
        // weightfactor * Volume Unit element * Volume ratio (real element/unit element)
        detJ*=w[i]*vol;
      
        pc[0] = Ji[0];
        pc[1] = Ji[1];
        pc[2] = Ji[2];
        pc[3] = Ji[3];
        pc[4] = Ji[4];
        pc[5] = Ji[5];
        pc[6] = Ji[6];
        pc[7] = Ji[7];
        pc[8] = Ji[8];
        pc[9] = detJ;
        
        // Build local stiffness matrix
        // Get the local derivatives of the basis functions in the basis element
        // They are all the same and are thus precomputed in matrix d
        const double *Nxi = &d[i][0];
        const double *Nyi = &d[i][local_dimension];
        const double *Nzi = &d[i][local_dimension2];
        // Gradients associated with the node we are calculating
        const double &Nxip = Nxi[row];
        const double &Nyip = Nyi[row];
        const double &Nzip = Nzi[row];
        // Calculating gradient shape function * inverse Jacobian * volume scaling factor
        const double uxp = pc[9]*(Nxip*pc[0]+Nyip*pc[1]+Nzip*pc[2]);
        const double uyp = pc[9]*(Nxip*pc[3]+Nyip*pc[4]+Nzip*pc[5]);
        const double uzp = pc[9]*(Nxip*pc[6]+Nyip*pc[7]+Nzip*pc[8]);
        // Matrix multiplication with conductivity tensor :
        const double uxyzpabc = uxp*Ca+uyp*Cb+uzp*Cc;
        const double uxyzpbde = uxp*Cb+uyp*Cd+uzp*Ce;
        const double uxyzpcef = uxp*Cc+uyp*Ce+uzp*Cf;
      
        // The above is constant for this node. Now multiply with the weight function
        // We assume the weight factors are the same as the local gradients 
        // Galerkin approximation:
         
        for (int j = 0; j<local_dimension; j++)
        {
          const double &Nxj = Nxi[j];
          const double &Nyj = Nyi[j];
          const double &Nzj = Nzi[j];
      
          // Matrix multiplication Gradient with inverse Jacobian:
          const double ux = Nxj*pc[0]+Nyj*pc[1]+Nzj*pc[2];
          const double uy = Nxj*pc[3]+Nyj*pc[4]+Nzj*pc[5];
          const double uz = Nxj*pc[6]+Nyj*pc[7]+Nzj*pc[8];
          
          // Add everything together into one coeffiecient of the matrix
          l_stiff[j] += ux*uxyzpabc+uy*uxyzpbde+uz*uxyzpcef;
        }
      }
    }
    else
    {      
      for(int i=0; i<local_dimension; i++)
        l_stiff[i] = 0.0;
     
       int local_dimension2=2*local_dimension;
      
      for (size_t i = 0; i < d.size(); i++)
      {
        std::vector<double>& pc = precompute[i];
      
        // Build local stiffness matrix
        // Get the local derivatives of the basis functions in the basis element
        // They are all the same and are thus precomputed in matrix d
        const double *Nxi = &d[i][0];
        const double *Nyi = &d[i][local_dimension];
        const double *Nzi = &d[i][local_dimension2];
        // Gradients associated with the node we are calculating
        const double &Nxip = Nxi[row];
        const double &Nyip = Nyi[row];
        const double &Nzip = Nzi[row];
        // Calculating gradient shape function * inverse Jacobian * volume scaling factor
        const double uxp = pc[9]*(Nxip*pc[0]+Nyip*pc[1]+Nzip*pc[2]);
        const double uyp = pc[9]*(Nxip*pc[3]+Nyip*pc[4]+Nzip*pc[5]);
        const double uzp = pc[9]*(Nxip*pc[6]+Nyip*pc[7]+Nzip*pc[8]);
        // Matrix multiplication with conductivity tensor :
        const double uxyzpabc = uxp*Ca+uyp*Cb+uzp*Cc;
        const double uxyzpbde = uxp*Cb+uyp*Cd+uzp*Ce;
        const double uxyzpcef = uxp*Cc+uyp*Ce+uzp*Cf;
      
        // The above is constant for this node. Now multiply with the weight function
        // We assume the weight factors are the same as the local gradients 
        // Galerkin approximation:
         
        for (int j = 0; j<local_dimension; j++)
        {
          const double &Nxj = Nxi[j];
          const double &Nyj = Nyi[j];
          const double &Nzj = Nzi[j];
      
          // Matrix multiplication Gradient with inverse Jacobian:
          const double ux = Nxj*pc[0]+Nyj*pc[1]+Nzj*pc[2];
          const double uy = Nxj*pc[3]+Nyj*pc[4]+Nzj*pc[5];
          const double uz = Nxj*pc[6]+Nyj*pc[7]+Nzj*pc[8];
          
          // Add everything together into one coeffiecient of the matrix
          l_stiff[j] += ux*uxyzpabc+uy*uxyzpbde+uz*uxyzpcef;
        }
      }
    }
  }
  
  return (true);
}


bool
FEMBuilder::
setup()
{	
  // The domain dimension
  domain_dimension = mesh_->dimensionality();
  if (domain_dimension < 1) 
  {
    algo_->error("This mesh type cannot be used for FE computations");
    return (false);
  }

  local_dimension_nodes = mesh_->num_nodes_per_elem();
  if (field_->basis_order() == 2)
  {
    local_dimension_add_nodes = mesh_->num_enodes_per_elem();
  }
  else
  {
    local_dimension_add_nodes = 0;
  }
  
  local_dimension_derivatives = 0;
  
  // Local degrees of freedom per element
  local_dimension = local_dimension_nodes + 
                    local_dimension_add_nodes + 
                    local_dimension_derivatives; //!< degrees of freedom (dofs) of system

  VMesh::Node::size_type mns;
  mesh_->size(mns);
  // Number of mesh points (not necessarily number of nodes)
  global_dimension_nodes = mns;
  if (field_->basis_order() == 2)
  {
    mesh_->synchronize(Mesh::ENODES_E);
    global_dimension_add_nodes =  mesh_->num_enodes();
  }
  else
  {
    global_dimension_add_nodes = 0;
  }
  global_dimension_derivatives = 0;
  global_dimension = global_dimension_nodes+
                     global_dimension_add_nodes+
                     global_dimension_derivatives;

  if (mns > 0) 
	{
		// We only need edges for the higher order basis in case of quatric lagrangian
		// Hence we should only synchronize it for this case
		if (global_dimension_add_nodes > 0) 
      mesh_->synchronize(Mesh::EDGES_E|Mesh::NODE_NEIGHBORS_E);
		else
      mesh_->synchronize(Mesh::NODE_NEIGHBORS_E);
  }
	else
	{
	  success_[0] = false;
	}
	rows_ = new Matrix::index_type[global_dimension+1];
  
  colidx_.resize(numprocessors_+1);
  return (true);
}



// -- callback routine to execute in parallel
void 
FEMBuilder::
parallel(int proc_num)
{
  success_[proc_num] = true;

  if (proc_num == 0)
  {
    try
    {
      success_[proc_num] = setup();
    }
    catch (...)
    {
      algo_->error(string("BuildFEMatrix could not setup FE Stiffness computation"));
      success_[proc_num] = false;
    }
  }
	
	barrier_.wait(numprocessors_);
  
  // In case one of the threads fails, we should have them fail all
	for (int q=0; q<numprocessors_;q++) 
	if (success_[q] == false) return;

	//! distributing dofs among processors
	const Matrix::index_type start_gd = (global_dimension * proc_num)/numprocessors_;
	const Matrix::index_type end_gd  = (global_dimension * (proc_num+1))/numprocessors_;

	//! creating sparse matrix structure
	std::vector<Matrix::index_type> mycols;

	VMesh::Elem::array_type ca;
	VMesh::Node::array_type na;
	VMesh::Edge::array_type ea;
	std::vector<Matrix::index_type> neib_dofs;

	//! loop over system dofs for this thread
	int cnt = 0;
	Matrix::size_type size_gd = end_gd-start_gd;
  try
	{
  	mycols.reserve((end_gd - start_gd)*local_dimension*8);  //<! rough estimate
  
		for (VMesh::Node::index_type i = start_gd; i<end_gd; i++)
		{
			rows_[i] = mycols.size();

			neib_dofs.clear();
			//! check for nodes
			if (i<global_dimension_nodes)
			{
				//! get neighboring cells for node
				mesh_->get_elems(ca, i);
			}
			else if (i<global_dimension_nodes+global_dimension_add_nodes)
			{
				//! check for additional nodes at edges
				//! get neighboring cells for node
				VMesh::Edge::index_type ii(i-global_dimension_nodes);
        mesh_->get_elems(ca,ii);
			}
			else
			{
				//! check for derivatives - to do
			}
		
			for(size_t j = 0; j < ca.size(); j++)
			{
				//! get neighboring nodes
				mesh_->get_nodes(na, ca[j]);

				for(size_t k = 0; k < na.size(); k++) 
				{
					neib_dofs.push_back(static_cast<Matrix::index_type>(na[k]));
				}

				//! check for additional nodes at edges
				if (global_dimension_add_nodes)
				{
					//! get neighboring edges
					mesh_->get_edges(ea, ca[j]);

					for(size_t k = 0; k < ea.size(); k++)
						neib_dofs.push_back(global_dimension + ea[k]);
				}
			}
		
			std::sort(neib_dofs.begin(), neib_dofs.end());

			for (size_t j=0; j<neib_dofs.size(); j++)
			{
				if (j == 0 || neib_dofs[j] != mycols.back())
				{
					mycols.push_back(neib_dofs[j]);
				}
			}
			if (proc_num == 0) 
			{
				cnt++;
				if (cnt == 200) { cnt = 0; algo_->update_progress(i,2*size_gd); }
			}    
		}

		colidx_[proc_num] = mycols.size();
	  success_[proc_num] = true;
	}
	catch (...)
	{
		algo_->error(string("BuildFEMatrix crashed mapping out stiffness matrix"));
	  success_[proc_num] = false;
	}

  //! check point
  barrier_.wait(numprocessors_);

	// Bail out if one of the processes failed
	for (int q=0; q<numprocessors_;q++) 
		if (success_[q] == false)
    {
      return;
    }
    
	std::vector<std::vector<double> > precompute;		
	Matrix::index_type st = 0;
	
  if (proc_num == 0) allcols_ = 0;

	try
	{
		if (proc_num == 0)
		{
  		for(int i=0; i<numprocessors_; i++)
			{
				const Matrix::index_type ns = colidx_[i];
				colidx_[i] = st;
				st += ns;
			}

			colidx_[numprocessors_] = st;
			allcols_ = new Matrix::index_type[st];
		}
		success_[proc_num] = true;
	}
	catch (...)
	{
    if (proc_num == 0) if (allcols_) delete allcols_;
		algo_->error(string("Could not allocate enough memory"));
	  success_[proc_num] = false;
	}	

  //! check point
  barrier_.wait(numprocessors_);

	// Bail out if one of the processes failed
	for (int q=0; q<numprocessors_;q++) 
		if (success_[q] == false) return;
	  
	try
	{
		//! updating global column by each of the processors
		const Matrix::index_type s = colidx_[proc_num];
		const size_t n = mycols.size();

		for(size_t i=0; i<n; i++)
			allcols_[i+s] = mycols[i];

		for(Matrix::index_type i = start_gd; i<end_gd; i++)
			rows_[i] += s;
		
		success_[proc_num] = true;
	}
	catch (...)
	{
		algo_->error(string("BuildFEMatrix crashed while setting up row compression"));
	  success_[proc_num] = false;
	}	
	

  //! check point
  barrier_.wait(numprocessors_);

	// Bail out if one of the processes failed
	for (int q=0; q<numprocessors_;q++) 
		if (success_[q] == false) return;
		
	try
	{	
		//! the main thread makes the matrix
		if (proc_num == 0)
		{
			rows_[global_dimension] = st;
			double* vals_ = new double[st];

			fematrix_ = new SparseRowMatrix(global_dimension, global_dimension, rows_, allcols_, st,vals_);
			fematrixhandle_ = fematrix_;
		}
		success_[proc_num] = true;
	}
	catch (...)
	{
		algo_->error(string("BuildFEMatrix crashed while creating final stiffness matrix"));
	  success_[proc_num] = false;
	}	

  //! check point
  barrier_.wait(numprocessors_);

	// Bail out if one of the processes failed
	for (int q=0; q<numprocessors_;q++) 
		if (success_[q] == false) return;

	try
	{
		//! zeroing in parallel
		const Matrix::index_type ns = colidx_[proc_num];
		const Matrix::index_type ne = colidx_[proc_num+1];
		double* a = &(fematrix_->a[ns]), *ae=&(fematrix_->a[ne]);
		while (a<ae) *a++=0.0;

		std::vector<VMesh::coords_type > ni_points;
		std::vector<double> ni_weights;
		std::vector<std::vector<double> > ni_derivatives;

		create_numerical_integration(ni_points, ni_weights, ni_derivatives);

		std::vector<double> lsml; //!< line of local stiffnes matrix
		lsml.resize(local_dimension);
					
		//! loop over system dofs for this thread
		cnt = 0;
		
		size_gd = end_gd-start_gd;
		for (VMesh::Node::index_type i = start_gd; i<end_gd; i++)
		{
			if (i < global_dimension_nodes)
			{
				//! check for nodes
				//! get neighboring cells for node
				mesh_->get_elems(ca,i);
			}
			else if (i < global_dimension_nodes + global_dimension_add_nodes)
			{
				//! check for additional nodes at edges
				//! get neighboring cells for additional nodes
				VMesh::Edge::index_type ii(i-global_dimension_nodes);
				mesh_->get_elems(ca,ii);
			}
			else
			{
				//! check for derivatives - to do
			}
		
			//! loop over elements attributed elements
			
			if (mesh_->is_regularmesh())
			{
				for (size_t j = 0; j < ca.size(); j++)
				{
					mesh_->get_nodes(na, ca[j]); //!< get neighboring nodes
					neib_dofs.resize(na.size());
					for(size_t k = 0; k < na.size(); k++)
					{
						neib_dofs[k] = na[k]; // Must cast to (int) for SGI compiler :-(
					}
					
					for(size_t k = 0; k < na.size(); k++)
					{
						if (na[k] == i) 
						{
							build_local_matrix_regular(ca[j], k , lsml, ni_points, ni_weights, ni_derivatives,precompute);
							add_lcl_gbl(i, neib_dofs, lsml);
						}
					}
				}
			}
			else
			{
				for (size_t j = 0; j < ca.size(); j++)
				{
					neib_dofs.clear();
					mesh_->get_nodes(na, ca[j]); //!< get neighboring nodes
					for(size_t k = 0; k < na.size(); k++)
					{
						neib_dofs.push_back(na[k]); // Must cast to (int) for SGI compiler :-(
					}
					//! check for additional nodes at edges
					if (global_dimension_add_nodes)
					{
						mesh_->get_edges(ea, ca[j]); //!< get neighboring edges
						for(size_t k = 0; k < ea.size(); k++)
						{
							neib_dofs.push_back(global_dimension + ea[k]);
						}
					}
					
					ASSERT((int)neib_dofs.size() == local_dimension);
					for(size_t k = 0; k < na.size(); k++)
					{
						if (na[k] == i) 
						{
							build_local_matrix(ca[j], k , lsml, ni_points, ni_weights, ni_derivatives);
							add_lcl_gbl(i, neib_dofs, lsml);
						}
					}

					if (global_dimension_add_nodes)
					{
						for(size_t k = 0; k < ea.size(); k++)
						{
							if (global_dimension + (int)ea[k] == i)
							{
								build_local_matrix(ca[j], k+na.size() , lsml, ni_points, ni_weights, ni_derivatives);
								add_lcl_gbl(i, neib_dofs, lsml);
							}
						}
					}
				}
			}
			
			if (proc_num == 0) 
			{
				cnt++;
				if (cnt == 200) { cnt = 0; algo_->update_progress(i+size_gd,2*size_gd); }
			}
		}
		success_[proc_num] = true;
	}
	catch (...)
	{
		algo_->error(string("BuildFEMatrix crashed while filling out stiffness matrix"));
	  success_[proc_num] = false;
	}	
	
  barrier_.wait(numprocessors_);
	
	// Bail out if one of the processes failed
	for (int q=0; q<numprocessors_;q++) 
		if (success_[q] == false) return;	
}

class BuildFEMatrixPrivateData : public AlgoData
{
  public:
    int generation_;
    vector<vector<double> > basis_values_;
    MatrixHandle basis_fematrix_;
};



bool 
BuildFEMatrixAlgo::
run(FieldHandle input, MatrixHandle ctable, MatrixHandle& output)
{
  algo_start("BuildFEMatrix",true);
  
  if (input.get_rep() == 0)
  {
    error("Could not obtain input field");
    algo_end(); return (false);
  }

  if (!(input->has_virtual_interface()))
  {
    error("Field does not have virtual interface");
    algo_end(); return (false);
  }
  
  if (input->vfield()->is_vector())
  {
    error("This function has not yet been defined for elements with vector data");
    algo_end(); return (false);
  }

  if (input->vfield()->basis_order()!=0)
  {
    error("This function has only been defined for data that is located at the elements");
    algo_end(); return (false);
  }

  if (ctable.get_rep())
  {
    if ((ctable->ncols() != 1)&&(ctable->ncols() != 6)&&(ctable->ncols() != 9))
    {
      error("Conductivity table needs to have 1, 6, or 9 columns");
      algo_end(); return (false);
    } 
    if (ctable->nrows() == 0)
    { 
      error("ConductivityTable is empty");
      algo_end(); return (false);
    }
  }

  Handle<FEMBuilder> builder = new FEMBuilder(this);
  // Call the the none pure version

  if (get_bool("generate_basis"))
  {
    BuildFEMatrixPrivateData* privatedata;
    get_privatedata(privatedata);
    
    
    if (ctable.get_rep()==0)
    {
      vector<pair<string,Tensor> > tens;
      
      input->get_property("conductivity_table",tens);
      
      if (tens.size() > 0)
      {
        ctable = new DenseMatrix(tens.size(),1);
        double* data = ctable->get_data_pointer();
        for (size_t i=0; i<tens.size();i++)
        {
          double t = tens[i].second.mat_[0][0];
          data[i] = t;
        }
      }
    }
      
    if (ctable.get_rep())
    {
      Matrix::size_type nconds = ctable->nrows();
      if ((input->vmesh()->generation() != privatedata->generation_)||
          (privatedata->basis_fematrix_.get_rep()==0))
      {
        MatrixHandle con = new DenseMatrix(nconds,1);
        double* data = con->get_data_pointer();
        for (Matrix::size_type i=0; i<nconds;i++) data[i] = 0.0;
        builder->build_matrix(input,con,privatedata->basis_fematrix_);
        if (privatedata->basis_fematrix_.get_rep() == 0)
        {
          error("Failed to build FEMatrix structure");
          algo_end(); return(false);
        }
        privatedata->basis_values_.resize(nconds);
        for (Matrix::size_type s=0; s< nconds; s++)
        {
          MatrixHandle temp;
          data[s] = 1.0;
          builder->build_matrix(input,con,temp);
          if (temp.get_rep() == 0)
          {
            error("Failed to build FEMatrix component for one of the tissue types");
            algo_end(); return(false);
          }

          SparseRowMatrix *m = temp->sparse();
          privatedata->basis_values_[s].resize(m->nnz);
          for (Matrix::size_type p=0; p< m->nnz; p++)
          {
            privatedata->basis_values_[s][p] = m->a[p];
          }
          data[s] = 0.0;
        }

        privatedata->generation_ = input->vmesh()->generation();
      }
      
      output = privatedata->basis_fematrix_;
      output.detach();
      
      SparseRowMatrix *m = output->sparse();
      double *sum = m->a;
      double *cdata = ctable->get_data_pointer();
      Matrix::size_type n = ctable->ncols();
      
      if (privatedata->basis_values_.size() > 0) 
        for (size_t p=0; p < privatedata->basis_values_[0].size(); p++) sum[p] = 0.0;
      
      for (int s=0; s<nconds; s++)
      {
        double weight = cdata[s*n];
        for (size_t p=0; p < privatedata->basis_values_[s].size(); p++)
        {
          sum[p] += weight * privatedata->basis_values_[s][p];
        }
      }

    }
    else
    {
      error("No conductivity table present: The generate_basis option only works for indexed conductivities");
      algo_end(); return (false);
    }
  }

  builder->build_matrix(input,ctable,output);

  if (output.get_rep() == 0)
  {    
    error("Could not build output matrix");
    algo_end(); return (false);
  }
  
  algo_end(); return (true);
}

} // end namespace SCIRun
