#include "UnwrapPlugin.h"
 
#include <sci_defs/insight_defs.h>

#include <string>
#include <Core/Events/BaseTool.h>
#include <Core/Datatypes/ITKDatatype.h>
#include <StandAlone/Apps/Seg3D/VolumeFilter.h>
#include <itkImageToImageFilter.h>
#include <itkCommand.h>
#include <itkOtsuThresholdImageFilter.h>

SET_PLUGIN_VERSION;

#define PI 3.14159
#define TORAD 1.0/PI

#define RADIAL_SAMPLES 360

#define SOBEL_THRESH 100
#define MAX_LAYERS 2

namespace SCIRun {

class ScrollUnwrapPlugin : public UnwrapPlugin {
	public:
		virtual std::string get_menu_string() const {
			return "Scroll Unwrapping";
		}
		virtual void menu_event() const {
			// printf("Hello from ExampleUnwrapPlugin\n");
		}
		BaseTool::propagation_state_e process_event(event_handle_t event) /*const*/ {
			// printf("Attempting to handle event inside plugin\n");
			// check for the FinishEvent signal generated by the start button
			if (dynamic_cast<FinishEvent *>(event.get_rep())) {
				if (!painter_->check_for_active_data_volume("Scroll Unwrapping filter"))
				{
					return STOP_E;
				}
				else if(!(painter_->mask_volume_.get_rep())) {
					painter_->set_status("Scroll Unwrapping filter requires a mask to be selected.");
					return STOP_E;
				}
			
				run_filter();
			}

			return CONTINUE_E;
		}
	private:
		void init_window(IplImage * im) {
			unwrap_win_ = new UnwrapPluginWindow(_T("Unwrapped View"), painter_->global_seg3dframe_pointer_, wxDefaultPosition, wxSize(900,750));
			unwrap_win_->scroll->set_image(im);
			unwrap_win_->Show(true);
		}	
		CvPoint calc_ray_outer(float theta, CvPoint center)
		{
			CvPoint result;
			float hyp = (float)center.x;
			float dx = hyp * cos(theta);
			float dy = hyp * sin(theta);

			result.x = center.x - dx;
			result.y = center.y - dy;

			return result;
		}

		void radial_sample(int width, int height, char* data, IplImage *unwrapped, int slice)
		{
			IplImage *cvcast = cvCreateImageHeader(cvSize(width, height),
					IPL_DEPTH_8U, 1);
			cvcast->imageData = data;

			// cvSaveImage("slice.png",cvcast);
			int cx = width/2;
			int cy = height/2;

			CvPoint center = cvPoint(cx,cy);

			unsigned char* linebuf;
			for(int sample = 0; sample < RADIAL_SAMPLES; sample++) {
				float theta = ((float)sample)*((2.0*PI)/(float)RADIAL_SAMPLES);
				CvPoint outer = calc_ray_outer(theta, center);

				// printf("%g:\t%d,%d\n", theta*(180.0/PI), outer.x, outer.y);
				cvClipLine(cvSize(width, height), &outer, &center);
				int linesize = abs(center.x-outer.x)+abs(center.y-outer.y)+1;
				linebuf = (unsigned char*)malloc(linesize);
				cvSampleLine(cvcast,outer,center,linebuf,4);
				
				IplImage *castline = cvCreateImageHeader(cvSize(linesize,1), IPL_DEPTH_8U, 1);
				castline->imageData = (char*)linebuf;

				IplImage *sobel = cvCreateImage(cvSize(linesize,1), IPL_DEPTH_8U, 1);

				cvSobel(castline, sobel, 1, 0, 3);

				int layer = 0;
				for(int i = 0; (i < linesize) && (layer < MAX_LAYERS); i++) {
					// printf(" %d,", (int)cvGetReal1D(sobel,i));
					if((int)cvGetReal1D(sobel,i) > SOBEL_THRESH) {
						int max = 0, max_i = 0;
						for(; i < linesize; i++) {
							int curval = (int)cvGetReal1D(sobel,i);
							if(curval == 0) break;
							if(curval > max) {
								max = curval;
								max_i = i;
							}
						}
						cvSetReal2D(unwrapped,slice,(layer*RADIAL_SAMPLES)+sample,cvGetReal1D(castline,max_i));
						// printf("%d\t",max);
						layer++;
					}
				}
				// printf("\n");
			
				/*	
				char filename[] = "line000.png";
				sprintf(filename,"line%03d.png",(int)(theta*(180.0/PI)));
				cvSaveImage(filename,sobel);
				*/
				
				cvReleaseImageHeader(&castline);
				cvReleaseImage(&sobel);

				free(linebuf);
			}
		}
		virtual void run_filter() {	
			printf("Scroll Unwrapping run\n");

			painter_->set_status("Running scroll unwrapping filter.");

			NrrdDataHandle source_label = painter_->mask_volume_->nrrd_handle_;
			NrrdDataHandle source_data = painter_->current_volume_->nrrd_handle_;

			const label_type mlabel = painter_->mask_volume_->label_;

			const size_t labelsize = VolumeOps::nrrd_elem_count(source_label);
			const size_t datasize = VolumeOps::nrrd_elem_count(source_data);

			ASSERT(labelsize == datasize);
			ASSERT(source_data->nrrd_->type == nrrdTypeFloat);
			ASSERT(source_label->nrrd_->type == LabelNrrdType);

			NrrdDataHandle masked = VolumeOps::create_clear_nrrd(source_data,
					nrrdTypeFloat);

			float *dst = (float*)masked->nrrd_->data;
			float *src = (float*)source_data->nrrd_->data;
			label_type *labeld = (label_type*)source_label->nrrd_->data;
			for(size_t i = 0; i < datasize; ++i, ++dst, ++labeld, ++*src) {
				if((*labeld & mlabel)) {
					*dst = *src;
				}
			}

			printf("Axis dimensions: %d x %d x %d\n",masked->nrrd_->axis[1].size,
					masked->nrrd_->axis[2].size,masked->nrrd_->axis[3].size);

			int width = masked->nrrd_->axis[1].size,
				height = masked->nrrd_->axis[2].size,
				slices = masked->nrrd_->axis[3].size;

			IplImage *unwrapped = cvCreateImage(cvSize(RADIAL_SAMPLES*MAX_LAYERS, slices), IPL_DEPTH_8U, 1);
	
			for(int i = 0; i < slices; i++) {
				radial_sample(width, height, ((char*)(masked->nrrd_->data))+(width * height * i), unwrapped, i);
			}

			init_window(unwrapped);
			
			cvSaveImage("unwrapped.png",unwrapped);
			cvReleaseImage(&unwrapped);

			/*
			painter_->volume_lock_.lock();

			// Save the source
			NrrdVolumeHandle source_volume = painter_->current_volume_;

			// Make a new label volume.
			NrrdDataHandle nrrdh = VolumeOps::create_clear_nrrd(painter_->current_volume_->nrrd_handle_, LabelNrrdType);
			const string name = painter_->unique_layer_name(painter_->current_volume_->name_ + " Scroll Label");
			painter_->volumes_.push_back(new NrrdVolume(painter_, name, nrrdh, 1));
			painter_->current_volume_ = painter_->volumes_.back();
			painter_->rebuild_layer_buttons();
			painter_->volume_lock_.unlock();

			painter_->update_progress(50);
	
 		  VolumeFilter<itk::OtsuThresholdImageFilter< ITKImageFloat3D, ITKImageLabel3D > > filter;
			filter.set_volume(painter_->current_volume_);
			filter->SetOutsideValue(1);
			filter->SetInsideValue(0);

			filter(source_volume->nrrd_handle_);
			*/

			painter_->update_progress(100);
			painter_->extract_all_window_slices();
			painter_->redraw_all();
			
			painter_->hide_tool_panel();
		}
};

EXPORT_CREATE_FUNCTION(UnwrapPlugin, ScrollUnwrapPlugin)
EXPORT_DELETE_FUNCTION(UnwrapPlugin, ScrollUnwrapPlugin)

}
