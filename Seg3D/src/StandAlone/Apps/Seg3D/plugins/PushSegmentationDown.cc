#include <StandAlone/Apps/Seg3D/FilterPlugin.h>
 
#include <sci_defs/insight_defs.h>

#include <string>
#include <Core/Events/BaseTool.h>
#include <Core/Datatypes/ITKDatatype.h>
#include <StandAlone/Apps/Seg3D/VolumeFilter.h>
#include <itkImageToImageFilter.h>
#include <itkCommand.h>
#include <itkOtsuThresholdImageFilter.h>

#include "highgui.h"

SET_PLUGIN_VERSION;

namespace SCIRun {

class PushSegPlugin : public FilterPlugin {
	public:
		virtual std::string get_menu_string() const {
			return "Push Segmentation";
		}
		virtual void menu_event() const {
			// printf("Hello from ExampleUnwrapPlugin\n");
		}
		BaseTool::propagation_state_e process_event(event_handle_t event) /*const*/ {
			// printf("Attempting to handle event inside plugin\n");
			// check for the FinishEvent signal generated by the start button
			if (dynamic_cast<FinishEvent *>(event.get_rep())) {
				if (!painter_->check_for_active_data_volume("Segmentation Push filter"))
				{
					return STOP_E;
				}
				else if(!(painter_->mask_volume_.get_rep())) {
					painter_->set_status("Segmentation Push filter requires a mask to be selected.");
					return STOP_E;
				}
			
				run_filter();
			}

			return CONTINUE_E;
		}
	private:
		virtual void run_filter() {	
			printf("Segmentation Push run\n");

			painter_->set_status("Running segmentation push filter.");

			painter_->volume_lock_.lock();
			NrrdVolumeHandle source_volume = painter_->current_volume_;			

			NrrdDataHandle source_label = painter_->mask_volume_->nrrd_handle_;

			// Make a new label volume.
		  const string name = painter_->current_volume_->name_ + " Segmentation Push";
		  painter_->create_new_label(painter_->current_volume_, name);

			painter_->rebuild_layer_buttons();
  		painter_->volume_lock_.unlock();

			painter_->start_progress();

		  label_type value = painter_->current_volume_->label_;

			// Get the data pointers.
		  NrrdDataHandle snrrd = source_volume->nrrd_handle_;
		  NrrdDataHandle dnrrd = painter_->current_volume_->nrrd_handle_;

			ASSERT(snrrd->nrrd_->type == nrrdTypeFloat);
		  ASSERT(dnrrd->nrrd_->type == LabelNrrdType);

			float *srcdata = (float *)snrrd->nrrd_->data;
			label_type *dstdata = (label_type *)dnrrd->nrrd_->data;
			label_type *lbldata = (label_type *)source_label->nrrd_->data;

			// Array to hold which indices to visit next
			vector<int> todo[2];
			int current = 0;

			// Add the seeds.
			float min, max;
			const size_t labelsize = VolumeOps::nrrd_elem_count(source_label);
			for (size_t i = 0; i < labelsize; ++i) {
				if(lbldata[i] > 0) {
					const float fillval =
						srcdata[i];

					// Push back the seed point
					todo[current].push_back(i);
					
					if (i == 0)
					{
						min = max = fillval;
					}
					else
					{
						min = fillval < min ? fillval : min; // Min(min, fillval);
						max = fillval > max ? fillval : max; // Max(max, fillval);
					}
				}
			}

			// Allocate a nrrd to mark where the flood fill has visited
			NrrdDataHandle done_handle = new NrrdData();
			size_t size[NRRD_DIM_MAX];
			size[0] = source_volume->nrrd_handle_->nrrd_->axis[0].size;
			size[1] = source_volume->nrrd_handle_->nrrd_->axis[1].size;
			size[2] = source_volume->nrrd_handle_->nrrd_->axis[2].size;
			size[3] = source_volume->nrrd_handle_->nrrd_->axis[3].size;
			nrrdAlloc_nva(done_handle->nrrd_, nrrdTypeUChar, 4, size);

			// Set the visited nrrd to empty.
			memset(done_handle->nrrd_->data, 0, 
						 source_volume->nrrd_handle_->nrrd_->axis[0].size *
						 source_volume->nrrd_handle_->nrrd_->axis[1].size *
						 source_volume->nrrd_handle_->nrrd_->axis[2].size * 
						 source_volume->nrrd_handle_->nrrd_->axis[3].size);

			unsigned char *done_data = (unsigned char *)done_handle->nrrd_->data;

			// Expand the leading edge until there is none.
			while (!todo[current].empty())
			{
				current = !current;
				todo[current].clear();
				for (unsigned int i = 0; i < todo[!current].size(); ++i)
				{
					dstdata[todo[!current][i]] |= value; // value
				}
				
				// For each axis
				for (unsigned int i = 0; i < todo[!current].size(); ++i)
				{
					// only push in the Z direction
					unsigned int a = 3;
						// Visit the previous and next neighbor indices along this axis
						for (int dir = -1; dir < 2; dir +=2) {
							// Neighbor index starts as current index
							int neighbor_index = todo[!current][i];

							// Index adjusted in direction we're looking at along axis
							neighbor_index = neighbor_index + (dir*(
										source_volume->nrrd_handle_->nrrd_->axis[1].size *
						 				source_volume->nrrd_handle_->nrrd_->axis[2].size));

							// Bail if this index is outside the volume
							if ((neighbor_index < 0) || (neighbor_index > labelsize)) continue;
							
							const size_t offset = neighbor_index;
							
							// Check to see if flood fill has already been here
							// Bail if the voxel has been visited
							if (done_data[offset]) continue;
							
							// Now check to see if this pixel is a candidate to be filled
							const float nbrval = srcdata[offset];
							
							// Bail if the voxel is outside the flood fill range
							if ((nbrval < min) /*|| (nbrval <= 0.0)*/ /*|| nbrval > max*/) continue;

							// Mark this voxel as visited
							done_data[offset] = 1;
							
							todo[current].push_back(neighbor_index);
						}
				}
			}
			painter_->finish_progress();

			painter_->extract_all_window_slices();
			painter_->redraw_all();
			
			painter_->hide_tool_panel();
		}
};

EXPORT_CREATE_FUNCTION(FilterPlugin, PushSegPlugin)
EXPORT_DELETE_FUNCTION(FilterPlugin, PushSegPlugin)

}
